<html>
	<head>
		<title>Car Learning</title>
		<script src='AI.js'></script>
		<style>
			body {
				background-color: black;
				margin: 0;
			}

			#cnv {
				background-color: white;
			}
		</style>
	</head>
	<body>
		<canvas id='cnv' width='512' height='360'></canvas>
		<script src='draw.js'></script>
		<script type="text/javascript">
			function radians(a) {
				return a * Math.PI / 180; 
			}

			function cast(o, d, w) {
				let x1 = w[0][0];
				let y1 = w[0][1];
				let x2 = w[1][0];
				let y2 = w[1][1];
				let x3 = o[0];
				let y3 = o[1];
				let x4 = o[0] + d[0];
				let y4 = o[1] + d[1];
				
				let den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
				
				if (den == 0) return;
				
				const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
				const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
				
				if (t > 0 && t < 1 && u > 0) {
					let pt = [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
					
					return pt
				}
				else return;
			}

			function distance(a, b) {
				let c = [a[0] - b[0], a[1] - b[1]];
				return (c[0] ** 2 + c[1] ** 2) ** 0.5;
			}

		    function det(a, b) {
		        return a[0] * b[1] - a[1] * b[0]
		    }

			function inter(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2) {				 
				let v1 = (bx2 - bx1) * (ay1-by1) - (by2-by1) * (ax1 - bx1);
				let v2 = (bx2 - bx1) * (ay2-by1) - (by2-by1) * (ax2 - bx1);
				let v3 = (ax2 - ax1) * (by1-ay1) - (ay2-ay1) * (bx1 - ax1);
				let v4 = (ax2 - ax1) * (by2-ay1) - (ay2-ay1) * (bx2 - ax1);

				return (v1 * v2 <= 0) && (v3 * v4 <= 0) &&
		              !((((ax1 == bx1) && (ay1 == by1))
		                    || ((ax1 == bx1) && (ay1 == by1))
		                    || ((ax2 == bx1) && (ay2 == by1))
		                    || ((ax1 == bx2) && (ay1 == by2))
		                    || ((ax2 == bx2) && (ay2 == by2))
		               ));
			}

			class Car {
				constructor(w, h, c, x, y) {
					this.points = [[-w/2, -h/2], [w/2, -h/2], [w/2, h/2], [-w/2, h/2]];
					this.color = c;
					this.rc = 20;
					this.n = new NeuralNetwork([this.rc, 60, 80, 2]);
					this.a = 0;
					this.w = w;
					this.h = h;
					this.x = w/2 + x;
					this.y = h/2 + y;

					this.score = 0;
				}

				think(m) {
					let res = this.n.run(this.trayce(m));
					this.move(Math.max(0.1, res[0]));
					if (res[1] > 0.51) this.rotate(0.5);
					if (res[1] < 0.49) this.rotate(-0.5);
				}

				trayce(map) {
					let scene = [];
		
					for (let r = Math.floor(-this.rc/2); r < Math.floor(this.rc/2); r++) {
						let closest = null;
						let record = Infinity;
						
						for (let w of map) {
							let d = [0, 1];

							let pt = cast([this.x, this.y], d, w);
							
							if (pt) {
								let p = [this.x, this.y];
								let d = distance(pt, p);
								
								if (d > 100) {
									if (d < record) {
										record = d;
										closest = pt;
									}
									
									record = Math.min(d, record);
								}
							}
						}
						
						scene[r] = record < 100 ? 100 - record : 0;
					}

					return scene;
				}

				move(s) {
					let dir = [0, 1];
					dir[0] = dir[0] * Math.cos(radians(this.a)) + dir[1] * Math.sin(-radians(this.a));
					dir[1] = dir[0] * Math.sin(radians(this.a)) + dir[1] * Math.cos(radians(this.a));
					this.x += dir[0] * -s;
					this.y += dir[1] * -s;
				}

				rotate(a) {
					if (Math.abs(a) > 5) {
						if (a < 0) a = -5
						else a = 5
					}
					this.a += a;
					this.a = this.a % 360;
					let points = [[-this.w/2, -this.h/2], [this.w/2, -this.h/2], [this.w/2, this.h/2], [-this.w/2, this.h/2]];
					for (let i = 0; i < this.points.length; i++) {
						this.points[i][0] = points[i][0] * Math.cos(radians(this.a)) + points[i][1] * Math.sin(-radians(this.a));
						this.points[i][1] = points[i][0] * Math.sin(radians(this.a)) + points[i][1] * Math.cos(radians(this.a));
					}
				}

				draw() {
					let points = [];
					for (let i = 0; i < this.points.length; i++) {
						let p = [this.points[i][0] + this.x, this.points[i][1] + this.y]
						points.push(p);
					}
					polygon(points, this.color);
				}

				collide(map) {
					for (let w of map) {
						let p = this.points;
						if (inter(w[0][0], w[0][1], w[1][0], w[1][1],
								p[0][0]+this.x, p[0][1]+this.y, p[1][0]+this.x, p[1][1]+this.y))
							return true;
						if (inter(w[0][0], w[0][1], w[1][0], w[1][1],
								p[1][0]+this.x, p[1][1]+this.y, p[2][0]+this.x, p[2][1]+this.y))
							return true;
						if (inter(w[0][0], w[0][1], w[1][0], w[1][1],
								p[2][0]+this.x, p[2][1]+this.y, p[3][0]+this.x, p[3][1]+this.y))
							return true;
						if (inter(w[0][0], w[0][1], w[1][0], w[1][1],
								p[3][0]+this.x, p[3][1]+this.y, p[0][0]+this.x, p[0][1]+this.y))
							return true;
					}

					return false;
				}
 			}

 			var run = true;
 			var cars = [];
 			var dead_cars = [];
 			var map = [
 				[[50, 30], [200, 40]],
 				[[50, 30], [30, 100]],
 				[[30, 100], [80, 200]],
 				[[80, 200], [70, 300]],
 				[[70, 300], [90, 310]],
 				[[90, 310], [200, 300]],
 				[[200, 300], [400, 310]],
 				[[400, 310], [420, 150]],
 				[[420, 150], [400, 70]],
 				[[400, 70], [200, 40]],

 				[[350, 120], [200, 90]],
 				[[200, 90], [90, 80]],
 				[[90, 80], [90, 110]],
 				[[90, 110], [135, 180]],
 				[[135, 180], [125, 260]],
 				[[125, 260], [190, 255]],
 				[[190, 255], [350, 260]],
 				[[350, 260], [365, 140]],
 				[[365, 140], [350, 120]]
 			]

 			var c_w = 20;
 			var c_h = 40;

 			let speed = 1000/60;

 			function generate_cars(bc) {
 				cars = [];

 				for (let i = 0; i < 50; i++) { 
	 				let c = new Car(c_w, c_h, 'gray', 380, 150);

	 				if (bc) {
	 					c.n.evolution(bc[Math.floor(Math.random()*bc.length)].n);
	 				}

	 				cars.push(c);
 				}
 			}

 			let time = 0;

 			function update() {
 				clear();

 				let lc = null;

 				for (let c = 0; c < cars.length; c++) {
 					cars[c].think(map);
 					cars[c].draw();
 					cars[c].score++;
 					if (cars[c] == lc) {run = false; return}
 					lc = cars[c];
 					if (cars[c].collide(map)) {
 						dead_cars.push(cars[c]);
 						cars.splice(c, 1)
 					}
 				}

 				for (let i of map) {
 					line(i[0][0], i[0][1], i[1][0], i[1][1], 'brown');
 				}

 				time++;

 				if (cars.length < 1 || time > 1000) {
 					run = false;
 					create_new_popul();
 					return;
 				}

 				if (run)
 					setTimeout(update, speed);
 			}

 			function create_new_popul() {
 				let best = [dead_cars[0], dead_cars[1], dead_cars[2], dead_cars[3]];

 				for (let i = best.length-1; i < dead_cars; i++) {
 					for (let j = 0; j < best.length; j++) {
 						if (best[j].score < dead_cars[i].score) best[j] = dead_cars[i];
 					}
 				}

 				dead_cars = [];

 				generate_cars(best);
 				run = true;
 				update();
 			}

 			generate_cars();
 			update();
		</script>
	</body>
</html>